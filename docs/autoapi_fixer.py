#!/usr/bin/env python3
# ðŸŒ€ Eidosian AutoAPI Fixer
"""
AutoAPI Fixer - Repairing AutoAPI-Generated Documentation

This script identifies and fixes common issues in documentation files
generated by the Sphinx AutoAPI extension. It handles indentation problems,
code blocks, inline literals, cross-references, and duplicate object descriptions.

Following Eidosian principles of:
- Precision as Style: Clean, correctly formatted documentation
- Structure as Control: Uniform structure across all auto-generated files
- Recursive Refinement: Systematic identification and repair of issues
"""

import os
import re
import sys
import logging
from pathlib import Path
from typing import Dict, List, Set, Tuple, Optional, Any

# ðŸ“Š Structured Logging - Self-Awareness Foundation
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)8s] %(message)s (%(filename)s:%(lineno)s)"
)
logger = logging.getLogger("eidosian_docs.autoapi_fixer")

class AutoAPIFixer:
    """Fixes common issues in documentation generated by AutoAPI with surgical precision."""
    
    def __init__(self, docs_dir: Path):
        self.docs_dir = docs_dir
        self.autoapi_dir = docs_dir / "autoapi"  # ðŸ” Where AutoAPI dumps its treasures
        self.fixed_count = 0  # ðŸ§® Track our victories
        self.exceptions_list = set()  # ðŸ§© Collection of unique exception classes
        self.duplicated_objects = set()  # ðŸ”„ Track objects that appear more than once
        
    def discover_exceptions(self) -> None:
        """
        Discover all exception classes defined in the project.
        Like a detective finding all the suspects! ðŸ•µï¸â€â™‚ï¸
        """
        exceptions_file = self.autoapi_dir / "ollama_forge" / "exceptions" / "index.rst"
        if exceptions_file.exists():
            with open(exceptions_file, "r", encoding="utf-8") as f:
                content = f.read()
                
            # Find all exception classes defined in exceptions module
            matches = re.finditer(r'^\.\. py:(?:class|exception):: ([A-Za-z0-9_]+(?:Error|Exception))', 
                                  content, re.MULTILINE)
            for match in matches:
                self.exceptions_list.add(match.group(1))
                
            logger.info(f"ðŸ” Discovered {len(self.exceptions_list)} exception classes")
        else:
            logger.warning("ðŸ§© Could not find exceptions module documentation - are we living in a perfect world?")
            
    def fix_all_files(self) -> int:
        """
        Fix all autoapi-generated documentation files with relentless precision.
        
        Returns:
            Number of files fixed (Victory count! ðŸ†)
        """
        if not self.autoapi_dir.exists():
            logger.warning(f"âš ï¸ AutoAPI directory not found at {self.autoapi_dir}")
            return 0
            
        # First discover all exception classes - know your enemies!
        self.discover_exceptions()
            
        # Process all RST files in autoapi directory - leaving no stone unturned
        for rst_file in self.autoapi_dir.glob("**/*.rst"):
            try:
                if self.fix_file(rst_file):
                    self.fixed_count += 1
            except Exception as e:
                logger.error(f"ðŸ’¥ Error processing {rst_file}: {e}")
                
        logger.info(f"âœ¨ Fixed {self.fixed_count} files")
        logger.info(f"ðŸ”§ Fixed {len(self.duplicated_objects)} duplicated object descriptions")
        return self.fixed_count
    
    def fix_file(self, file_path: Path) -> bool:
        """
        Fix formatting issues in a single file.
        
        Args:
            file_path: Path to the file to fix
            
        Returns:
            True if file was modified, False otherwise
        """
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
            
        # Apply each fix
        updated_content = content
        updated_content = self.fix_duplicate_descriptions(updated_content)
        updated_content = self.fix_cross_references(updated_content)
        updated_content = self.fix_inline_literals(updated_content)
        updated_content = self.fix_unexpected_indentation(updated_content)
        updated_content = self.fix_block_quotes(updated_content)
        
        # Write back if changed
        if updated_content != content:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(updated_content)
            logger.info(f"âœ… Fixed issues in {file_path.name}")
            return True
        return False
        
    def fix_duplicate_descriptions(self, content: str) -> str:
        """Fix duplicate object descriptions by adding :no-index: directives."""
        # Common duplicated objects
        patterns = [
            (r'(\.\. py:[a-z]+:: .*?OllamaClient\.base_url\n)', "base_url"),
            (r'(\.\. py:[a-z]+:: .*?OllamaClient\.timeout\n)', "timeout"),
            (r'(\.\. py:[a-z]+:: .*?OllamaClient\.max_retries\n)', "max_retries"),
            (r'(\.\. py:[a-z]+:: .*?__init__\(.*?\)\n)', "__init__"),
            (r'(\.\. py:[a-z]+:: .*?OllamaClient\n)', "OllamaClient"),
        ]
        
        for pattern, name in patterns:
            matches = list(re.finditer(pattern, content))
            if len(matches) > 1:
                # Add :noindex: to all occurrences except the first one
                for match in matches[1:]:
                    directive = match.group(1)
                    # Only add :noindex: if it doesn't already have it
                    if ':noindex:' not in directive:
                        replacement = f"{directive}   :noindex:\n"
                        content = content[:match.start(1)] + replacement + content[match.end(1):]
                        self.duplicated_objects.add(name)
        
        return content
    
    def fix_cross_references(self, content: str) -> str:
        """Fix ambiguous cross-references to exception classes."""
        if not self.exceptions_list:
            return content
            
        # Replace cross-references to exception classes with fully qualified references
        for exception in self.exceptions_list:
            # Pattern for inline references
            pattern = rf':(?:class|exc):`({exception})`'
            content = re.sub(
                pattern,
                r':class:`ollama_forge.exceptions.\1`',
                content
            )
            
            # Pattern for raises directives
            pattern = rf':raises\s+({exception}):'
            content = re.sub(
                pattern,
                r':raises ollama_forge.exceptions.\1:',
                content
            )
            
            # Pattern for references in parameter/return type documentation
            pattern = rf'([^\w.])({exception})([^\w`])'
            content = re.sub(
                pattern,
                r'\1ollama_forge.exceptions.\2\3',
                content
            )
        
        return content
    
    def fix_inline_literals(self, content: str) -> str:
        """Fix unmatched inline literals like `text without closing backtick."""
        # Pattern to find unmatched backticks
        lines = content.split('\n')
        for i in range(len(lines)):
            # Count backticks in line
            count = lines[i].count('`')
            if count % 2 == 1:  # Odd number of backticks - likely an issue
                # Look for opening backtick without matching closing one
                if '`' in lines[i] and lines[i].rfind('`') == lines[i].find('`'):
                    lines[i] += '`'  # Add closing backtick
                    
                # Special case for sphinx rst equations
                if ':math:`' in lines[i] and not lines[i].endswith('`'):
                    lines[i] += '`'
        
        # Fix backtick spans across lines (common in docstring conversion)
        for i in range(len(lines) - 1):
            if lines[i].count('`') % 2 == 1 and lines[i+1].count('`') % 2 == 1:
                # If line ends with backtick and next starts with backtick, merge them
                if lines[i].endswith('`') and lines[i+1].startswith('`'):
                    lines[i] = lines[i][:-1]
                    lines[i+1] = lines[i+1][1:]
        
        return '\n'.join(lines)
    
    def fix_unexpected_indentation(self, content: str) -> str:
        """Fix unexpected indentation in docstrings."""
        # Look for lines that have an unexpected indentation
        pattern = r'(^\s+)(\S.*?)\n\s{4,}(\S)'
        content = re.sub(pattern, r'\1\2\n\1    \3', content, flags=re.MULTILINE)
        
        # Fix indentation of code examples
        lines = content.split('\n')
        in_example = False
        in_code_block = False
        result = []
        
        for i, line in enumerate(lines):
            # Detect example sections
            if 'Example' in line and ':' in line:
                in_example = True
                result.append(line)
                # Make sure we have a blank line after Example:
                if i+1 < len(lines) and lines[i+1].strip():
                    result.append('')
                continue
                
            # Fix code blocks within examples
            if in_example and line.strip() == '::':
                in_code_block = True
                result.append(line)
                # Make sure we have a blank line after ::
                if i+1 < len(lines) and lines[i+1].strip():
                    result.append('')
                continue
                
            # Ensure code blocks have proper indentation
            if in_code_block and line.strip():
                # End code block on first non-indented line
                if not line.startswith('    '):
                    in_code_block = False
                    in_example = False
                    result.append(line)
                    continue
                
                # Fix inconsistent indentation
                indent = len(line) - len(line.lstrip())
                if 0 < indent < 4:
                    result.append('    ' + line.lstrip())
                    continue
            
            result.append(line)
                
        return '\n'.join(result)
    
    def fix_block_quotes(self, content: str) -> str:
        """Fix block quote formatting issues."""
        # Fix block quotes that don't have proper blank lines after them
        pattern = r'(\n\s+[^\s].*\n)([^\s])'
        content = re.sub(pattern, r'\1\n\2', content)
        
        # Ensure blank lines before and after literal blocks
        pattern = r'([^\n])::\n(\S)'
        content = re.sub(pattern, r'\1::\n\n\2', content)
        
        return content
    

if __name__ == "__main__":
    # Find repository root and docs directory
    script_dir = Path(__file__).resolve().parent
    repo_root = script_dir.parent
    docs_dir = repo_root / "docs"
    
    # Run the fixer
    fixer = AutoAPIFixer(docs_dir)
    fixed_count = fixer.fix_all_files()
    
    logger.info(f"ðŸ”§ AutoAPI fixer completed. Fixed {fixed_count} files.")
